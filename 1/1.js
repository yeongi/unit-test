let total = 0;

// 서드파티 함수 호출
const makeLogger = () => {
    return {
        info:()=>{}
    }
};


export const totalSoFar = () => {
    return total;
}

const logger = makeLogger();

export const sum = (numbers) => {
    const [a,b] = numbers.split(",");

    // 종료점 1 : 서드 파티를 호출하는 종료점
    // 제일 어려운놈이다 < 모의 객체를 만들어서 테스트 결과를 임의로 조작해야 한다.
    logger.info();

    const res = Number.parseInt(a, 10) + Number.parseInt(b,10);
    // 상태 값을 변경하는 종료점 << 의도 대로 흘러갔는지 확인해야 한다.
    total += res;

    // 종료점 2
    // 반환값이 있는 종료점 << 제일 테스트하기 쉽다.
    return res;
}

// 각 종료점 마다 테스트 케이스를 작성하면
// 영향을 주지 않고 더 읽기 쉽고, 디버깅 하기 쉽다.

// ! 서드 파티를 호출하는 종료점은 제일 줄여야 한다.
// ! 테스트 하기 쉬운 코드를 작성한다는 것이 아닐까 

// ---

// 좋은 단위 테스트란? 
// 1. 테스트 작성자 의도를 이해하기 쉬워야 한다.
// 2. 읽고 쓰기 쉬워야 한다.
// 3. 테스트를 자동화 할 수 있어야 한다.
// 같은 조건에서 실행 결과는 항상 같아야 한다.
// 의미 있는 테스트여야 하고, 구체적인 결과를 제공하여 문제를 쉽게 파악하고 해결할 수 있어야 한다.
// 누구나 쉽게 실행할 수 있어야 한다.
// 실패할 경우 무엇이 잘못되었는지 쉽게 알 수 있어야 한다.
// 빠르게 실행
// 테스트환경을 일관 되게 유지 하고, 테스트 결과가 항상 예측 가능해야 한다.
// 다른 테스트와 완전히 독립적으로 실행되어야 한다.
// 시스템 파일, 네트워크, 데이터베이스가 없어도 메모리 내에서 실행되어야 한다.
// 가능한 한 동기적인 흐름으로 실행되어야 한다. 
